<section xml:id="inheritance_invoking-the-parent-class-s-method">
        <title>Invoking the Parent Class's Method</title>
        <p>Sometimes the parent class has a useful method, but you just need to execute a little extra code when running the subclass's method. You can override the parent class's method in the subclass's method with the same name, but also invoke the parent class's method. Here's how.</p>
        <p>Say you wanted the <c>Dog</c> subclass of <c>Pet</c> to say <q>Arf! Thanks!</q> when the <c>feed</c> method is called, as well as executing the code in the original method.</p>
        <p>Here's the original <c>Pet</c> class again.</p>

    <program xml:id="inheritance_pet_class_copy" interactive="activecode" language="python">
    
        <input>
from random import randrange

# Here's the original Pet class
class Pet():
    boredom_decrement = 4
    hunger_decrement = 6
    boredom_threshold = 5
    hunger_threshold = 10
    sounds = ['Mrrp']
    def __init__(self, name = "Kitty"):
        self.name = name
        self.hunger = randrange(self.hunger_threshold)
        self.boredom = randrange(self.boredom_threshold)
        self.sounds = self.sounds[:]  # copy the class attribute, so that when we make changes to it, we won't affect the other Pets in the class

    def clock_tick(self):
        self.boredom += 1
        self.hunger += 1

    def mood(self):
        if self.hunger &lt;= self.hunger_threshold and self.boredom &lt;= self.boredom_threshold:
            return "happy"
        elif self.hunger &gt; self.hunger_threshold:
            return "hungry"
        else:
            return "bored"

    def __str__(self):
        state = "     I'm " + self.name + ". "
        state += " I feel " + self.mood() + ". "
        # state += "Hunger %d Boredom %d Words %s" % (self.hunger, self.boredom, self.sounds)
        return state

    def hi(self):
        print(self.sounds[randrange(len(self.sounds))])
        self.reduce_boredom()

    def teach(self, word):
        self.sounds.append(word)
        self.reduce_boredom()

    def feed(self):
        print("Called Pet.feed()")
        self.reduce_hunger()

    def reduce_hunger(self):
        self.hunger = max(0, self.hunger - self.hunger_decrement)

    def reduce_boredom(self):
        self.boredom = max(0, self.boredom - self.boredom_decrement)
        </input>
<tests>


</tests>

    </program>
        <p>And here's a subclass that overrides <c>feed()</c> by invoking the the parent class's <c>feed()</c> method; it then also executes an extra line of code. It does this by calling the built-in function <c>super()</c>. The <c>super()</c> function returns a special object that allows you to invoke the method of the parent class. So to call the parent class's <c>feed()</c> method (<c>Pet.feed()</c>), we say <c>super().feed()</c>.</p>

    <program xml:id="feed_me_example" interactive="activecode" language="python">
    
        <input>
from random import randrange

class Dog(Pet):
    sounds = ['Woof', 'Ruff']

    def feed(self):
        super().feed()
        print("Arf! Thanks!")

d1 = Dog("Astro")

d1.feed()
        </input>
<tests>


</tests>

    </program>
        <note>
            <p>Another way to invoke the parent's method is to explicitly refer to the parent class' method and invoke it on the instance. So, in this case, we could say <c>Pet.feed(self)</c>. This is a little more explicit, but it's also a little less flexible. If we later change the name of the parent class, we'd have to change it in all the subclasses. Also, if we later change the class hierarchy, so that <c>Dog</c> is a subclass of some other class, we'd have to change the code in all the subclasses. So, it's better to use <c>super()</c>.</p>
        </note>
        <p>This technique is very often used with the <c>__init__</c> method for a subclass. Suppose that some extra instance variables are defined for the subclass. When you invoke the constructor, you pass all the regular parameters for the parent class, plus the extra ones for the subclass. The subclass' <c>__init__</c> method then stores the extra parameters in instance variables and calls the parent class'   <c>__init__</c> method to store the common parameters in instance variables and do any other initialization that it normally does.</p>
        <p>Let's say we want to create a subclass of <c>Pet</c>, called <c>Bird</c>, and we want it to take an extra parameter, <c>chirp_number</c>, with a default value of <c>2</c>, and have an extra instance variable, <c>self.chirp_number</c>. Then, we'll use this in the <c>hi</c> method to make more than one sound.</p>

    <program xml:id="super_methods_1" interactive="activecode" language="python">
    
        <input>
class Bird(Pet):
    sounds = ["chirp"]
    def __init__(self, name="Kitty", chirp_number=2):
        super().__init__(name) # call the parent class's constructor
        self.chirp_number = chirp_number # now, also assign the new instance variable

    def hi(self):
        for i in range(self.chirp_number):
            print(self.sounds[randrange(len(self.sounds))])
        self.reduce_boredom()

b1 = Bird('tweety', 5)
b1.teach("Polly wanna cracker")
b1.hi()
        </input>
<tests>


</tests>

    </program>
        

    <exercise label="question_inheritance_4">
        <statement>

        <p>What will the following code print (assuming we use the above definitions of <c>Bird</c> and <c>Pet</c>):</p>
        <pre>b2 = Bird('Sunny', 7)
print(b2.sounds)</pre>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>7</p>
                </statement>
                <feedback>
                    <p>This would print if the code was print(b2.chirp_number).</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>["Mrrp"]</p>
                </statement>
                <feedback>
                    <p>We set b2 to be Bird('Sunny', 7) above.  Bird is a subclass of Pet, which has ["Mrrp"] for sounds, but Bird has a different value for that class variable. The interpreter looks in the subclass first.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>["chirp"]</p>
                </statement>
                <feedback>
                    <p>The interpeter finds the value in the class variable for the class Bird.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Error</p>
                </statement>
                <feedback>
                    <p>We ran set b2 to be Bird('Sunny', 7) above.  Bird has a value set for the attribute sounds.</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="question_inheritance_5">
        <statement>

        <p>For the <c>Dog</c> class defined in the earlier activecode window, what would happen when <c>d1.feed()</c> is run if the <c>super().feed()</c> line was deleted?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>Error when invoked</p>
                </statement>
                <feedback>
                    <p>Since we are no longer calling the parent method in the subclass method definition, the actions defined in the parent method feed will not happen, and only Arf! Thanks! will be printed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The string "Arf! Thanks!" would not print out but d1 would still have its hunger reduced.</p>
                </statement>
                <feedback>
                    <p>Remember that the Python interpreter checks for the existence of feed in the Dog class and looks for feed in Pet only if it isn't found in Dog.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>The string "Arf! Thanks!" would still print out but d1 would not have its hunger reduced.</p>
                </statement>
                <feedback>
                    <p>Since we are no longer calling the parent Pet class's method in the Dog subclass's method definition, the class definition will override the parent method.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Nothing would be different. It is the same as the current code.</p>
                </statement>
                <feedback>
                    <p>Remember that the Python interpreter checks for the existence of feed in the Dog class and looks for feed in Pet only if it isn't found in Dog.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
    </section>

